# 변수

## 변수

### 변수란?

:::info
_변할 수 있는 수_, _변할 수 있는 정보_

```js
var x = 3;
let y = 4;
const z = 5;
```


x,y,z값과 3,4,5의 값은 메모리에 올라간다.
const를 제외하고 나머지의 값들은 변경이 가능하다!
:::

### 변수명 지정

- 첫글자 숫자 X
- 예약어(while,for ...) 사용 X
- `$`, `_`를 제외한 공백, 특수문자, 구두점은 사용 X

### 변수의 특징

- 변수 선언은 `var`, `let`, `const` 키워드를 사용.
  - var, let은 변수
  - const는 변경할 수 없는 수(상수를 의미)
- var 키워드는 초기화가 필요 없고 재할당 및 생략 가능. 하지만 **엄격모드(strict mode)**에서는 에러가 발생
- let과 const는 블록-레벨 선언으로 불리며, 선언된 코드 블록 밖에서 접근할 수 없으며 재정의가 불가능. **특히 const 의 경우에는 반드시 초기화가 필요**

:::danger
변수 선언 `var`은 현재 권장하지 않는다. 재할당 뿐만이 아닌 똑같은 변수명으로 재선언이 가능하기 떄문에
코드에서 의도하지 않은 에러가 발생할 수 있다.
:::

```js
'use strict';  // 자바스크립트를 엄격모드에서 실행.

valueA;        // 변수 키워드 생략은 엄격모드에서 에러발생!
var valueA;
var valueA;
let valueA;    // 재정의로 인한 에러발생!
const my_name; // 초기화가 없어서 에러발생!
```

:::caution
`let`과 `const`

- let은 재할당이 가능한 변수를 선언할 때 사용
- const는 재할당이 불가능한 상수를 선언할 때 사용
:::

## `typeof()`

- 변수의 타입을 확인하는 메소드

```js
// typeof를 해서 값의 형태를 확인할 수가 있다.
console.log(typeof 10); //number
console.log(typeof "10"); //string
console.log(typeof [1, 2, 3]); //object

console.log(typeof null); //object
console.log(typeof []); //object
console.log(typeof {}); //object
console.log(typeof function () {}); //function
console.log(typeof /a/g); //object
console.log(typeof true); //boolean
console.log(typeof NaN); //number
console.log(typeof undefined); //undefined
```


:::danger
`typeof(null)` 과 `typeof([1,2,3])`은 왜 object로 출력이 될까?

정확한 이유는 모른다. 하지만 개발자가 버그라고 인정을 해버렸다...
또한 Array와 Object의 사용법 또한 다르지만
Object라고 출력하는 이유는 key의 값이 index를 의미하고, value값이 array의 index 값을 의미하는 것 같다.
이외에도 다른 결과값에 대해서 몇 가지가 이해안되는 경우가 있다.
:::

## Data type(데이터 타입)

### **primitive data types**(원시적 데이터 타입)

- primitive data types의 데이터는 메모리 상에 고정된 크기로 저장 변수가 원시 데이터 값을 보관. 
- 변수에 새 값이 할당이 될 경우, 변수에 할당된 메모리 새로운 영역에 저장된 값을 바로 변경한다.
- string, number, bigint, boolean, undefined, symbol, null

```js
//값 변경 불가!
let x = "hello";
console.log(x[0]);
x[0] = 10; // 값의 변경이 불가능

//값의 참조가 저장되는 것이 아닌, 값 자체를 가리키게 됩니다.(얕은 복사, 깊은 복사때 중요)
let xx = 10;
let yy = xx;
xx = 20;
console.log(xx, yy);
```
<details>
<summary>Primitive 데이터 타입에 대한 사진 및 부가 설명</summary>
<div markdown="1">

:::note

![image](https://github.com/JJamVa/FE-JJamVa/assets/80045006/e12f6e7c-4194-49c7-a003-2fda396dfef2)

let a = 10이라고 선언하면 메모리 어느 위치에 10이라는 값이 할당되며, 그 영역을 지목하게 된다.<br/>
let b = a 하면, b는 a에 대한 메모리 주소를 지목한다.<br/>


![image](https://github.com/JJamVa/FE-JJamVa/assets/80045006/586c5945-824e-473f-92bd-031d5c9729ff)

선언되었던 a가 20이라는 새로운 값을 할당 받으면, 메모리의 다른 주소에 20이라는 값이 할당된다.<br/><br/>
그럼 b의 값은 어떻게..?<br/>
20을 선언했던 a의 메모리 주소를 따라가지 않는다.<br/> 이전의 let a = 10가 선언 되었을 때의 메모리 번지를 그대로 유지하고 있다.
:::

</div>
</details>

<!-- 사진 넣도록 하자 -->

### **reference data types**(참조 데이터 타입)
- reference data type의 데이터는 크기가 정해져 있지 않고 변수에 할당이 될 때, 값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장.
- 객체, 배열, 함수, 정규표현식


