# DP

## DP란?

- `Dynamic Programming(동적 계획법)`의 약자
- 복잡한 문제를 작은 부분 문제로 나누고, 한 번 구한 답을 **메모(캐싱)**하여 중복 계산을 피하는 기법
- 분할 정복과 달리, 부분 문제들이 서로 겹치는(Overlapping) 경우에 주로 사용

## DP의 사용 목적

- `최적화 문제`: 최대값/최소값(배낭 문제, 최단 경로 등)
- `경우의 수 계산`: 계단 오르기, 타일 채우기, 문자열 편집 거리
- `연속 부분 문제 처리`: 최장 증가 부분 수열(LIS), 최장 공통 부분 수열(LCS)
- `메모리 vs 시간 절약`: 재귀 깊이 제한 회피, 중복 연산 방지

## DP 코드 문제

- 계단 오르기
- 한번에 계단은 `1` 또는 `2` 또는 `3`칸 이동 가능
- 이때, 0번째 칸에서 계단 30번째 칸을 올라갈 모든 경우의 수 구하기

```js
let max = 30;
let dp = Array.from({ length: max + 1 }, () => 0);
dp[1] = 1;
dp[2] = 2;
dp[3] = 4;

for (let i = 4; i <= max; i++) {
  dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];
}

console.log(dp[30]);
```

:::note

1. dp 배열의 크기

- 배열의 크기를 `max + 1`로 선언한 이유는, 0번 계단부터 30번 계단까지 총 31개 인덱스를 모두 담기 위해서 생성

2. dp[i]의 의미

- `dp[i]`는 1번 계단에서 출발해 i번 계단까지 올라올 수 있는 **모든 경로의 수**를 의미

3. 초기값
- `dp[0] = 1` => 아무 이동 없이 해당 위치 도달
- `dp[1] = 1` => (1)
- `dp[2] = 2` => (1+1), (2)
- `dp[3] = 4` => (1+1+1), (1+2), (2+1), (3)

4. 점화식

- i번 계단에 오르는 경로를 마지막 한 걸음이 얼마나 멀리서 왔는지로 나누면

  1. 마지막이 1칸 => `i-1`번 계단에서 한 칸 올라옴 => `dp[i-1]`
  2. 마지막이 2칸 => `i-2`번 계단에서 두 칸 올라옴 => `dp[i-2]`
  3. 마지막이 3칸 => `i-3`번 계단에서 세 칸 올라옴 => `dp[i-3]`

- 세 경우는 서로 겹치지 않으므로,

```js
dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
```

5. 결론

미리 배열 크기를 할당하고, 점화식을 차례로 적용해 나가면 재귀 없이도 효율적으로 계산이 가능하다.<br/>

- `시간 복잡도`: O(n) — 각 i마다 상수 연산
- `공간 복잡도`: O(n) — dp 배열 크기만큼

:::


:::tip Dp 추천 알고리즘 문제집

[DP 알고리즘 문제 - 백준](https://www.acmicpc.net/workbook/view/7319)

:::
